import os
import zipfile
import cv2
import numpy as np
import matplotlib.pyplot as plt
from glob import glob

# Define paths (ensure the path separators are consistent)
data_path = r"C:\Users\Student\Desktop\New folder\ball_frames.zip"  # Adjust this path to the location of your ZIP file
extracted_folder = r"C:\Users\Student\Desktop\New folder\ball_frames"  # Folder to extract the ZIP contents

# Extract the ZIP file if not already extracted
if not os.path.exists(extracted_folder):
    with zipfile.ZipFile(data_path, 'r') as zip_ref:
        zip_ref.extractall(extracted_folder)

# Debugging step: List the contents of the extracted folder to check its structure
print("Contents of extracted folder:")
for root, dirs, files in os.walk(extracted_folder):
    print(f"Root: {root}")
    print(f"Directories: {dirs}")
    print(f"Files: {files}")

# Check for RGB and GT image files (assuming they are in the same folder)
rgb_images = sorted(glob(os.path.join(extracted_folder, "frame-*.png")))  # All frame-*.png files
mask_images = sorted(glob(os.path.join(extracted_folder, "frame-*_GT.png")))  # All frame-*GT.png files

# Debugging output for found files
print(f"Found {len(rgb_images)} RGB images.")
print(f"Found {len(mask_images)} mask images.")

# Check if images are found
if not rgb_images or not mask_images:
    print("No RGB or mask images found. Please check the paths.")
else:
    print(f"Found {len(rgb_images)} RGB images.")
    print(f"Found {len(mask_images)} mask images.")

# Function to segment the ball using color thresholding
def segment_ball(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    
    # Define color range for segmentation (tune based on dataset)
    lower_range = np.array([20, 100, 100])   # Lower bound of color
    upper_range = np.array([30, 255, 255])   # Upper bound of color

    # Create a binary mask
    mask = cv2.inRange(hsv, lower_range, upper_range)

    # Apply morphological operations to clean noise
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    
    return mask

# Function to compute Dice Similarity Score
def dice_score(seg, gt):
    seg = seg.astype(bool)
    gt = gt.astype(bool)
    intersection = np.logical_and(seg, gt).sum()
    return (2. * intersection) / (seg.sum() + gt.sum())

# Iterate over images, segment, and evaluate
dsc_scores = []
for rgb_path, mask_path in zip(rgb_images, mask_images):
    img = cv2.imread(rgb_path)
    gt_mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
    
    if img is None or gt_mask is None:
        print(f"Error loading image or mask: {rgb_path}, {mask_path}")
        continue
    
    # Convert ground-truth mask to binary
    gt_mask = (gt_mask > 127).astype(np.uint8) * 255
    
    # Perform segmentation
    segmented = segment_ball(img)
    
    # Check if segmentation generated any meaningful mask
    if np.sum(segmented) == 0:
        print(f"No object detected in image {rgb_path}. Skipping this image.")
        continue
    
    # Compute Dice Similarity Score
    dsc = dice_score(segmented, gt_mask)
    dsc_scores.append(dsc)
    
    # Show a few examples
    if len(dsc_scores) % 10 == 0:  # Show every 10th image
        plt.figure(figsize=(10, 3))
        plt.subplot(1, 3, 1)
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.title("Original Image")
        
        plt.subplot(1, 3, 2)
        plt.imshow(gt_mask, cmap="gray")
        plt.title("Ground Truth")
        
        plt.subplot(1, 3, 3)
        plt.imshow(segmented, cmap="gray")
        plt.title(f"Segmented Mask (DSC={dsc:.2f})")
        plt.show()

# Ensure we have scores before computing the mean and std
if dsc_scores:
    mean_dsc = np.mean(dsc_scores)
    std_dsc = np.std(dsc_scores)

    print(f"Mean DSC: {mean_dsc:.4f}, Standard Deviation: {std_dsc:.4f}")

    # Plot Dice scores for all images
    plt.figure(figsize=(10, 5))
    plt.bar(range(len(dsc_scores)), dsc_scores)
    plt.xlabel("Image Index")
    plt.ylabel("Dice Similarity Score")
    plt.title("DSC Scores for Each Image")
    plt.show()

   def save_visualizations(results, mean_dsc, std_dsc, best_frames, worst_frames):
    """Save visualizations to disk."""
    output_dir = os.path.join(os.path.dirname(extracted_folder), "results")
    os.makedirs(output_dir, exist_ok=True)
    
    # Save DSC bar chart
    plt.figure(figsize=(14, 8))
    image_indices = sorted(results.keys())
    dsc_values = [results[idx]['dsc'] for idx in image_indices]
    
    plt.bar(image_indices, dsc_values, color='skyblue', edgecolor='navy')
    plt.xlabel('Image Number (Index)', fontsize=12)
    plt.ylabel('Dice Similarity Coefficient (DSC)', fontsize=12)
    plt.title(f'Segmentation Performance\nMean DSC: {mean_dsc:.4f} Â± {std_dsc:.4f}', fontsize=14)
    plt.ylim(0, 1)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'dsc_results.png'), dpi=300)
    plt.close()
    
    # Save best and worst results
    fig = plt.figure(figsize=(20, 24))
    plt.suptitle('Appendix: Five Best and Five Worst Results', fontsize=20)
    
    # Plot best results
    for i, frame_num in enumerate(best_frames):
        result = results[frame_num]
        rgb = cv2.imread(result['rgb_path'])
        rgb = cv2.cvtColor(rgb, cv2.COLOR_BGR2RGB)
        
        # Original image
        ax1 = plt.subplot(5, 4, i*2+1)
        ax1.imshow(rgb)
        ax1.set_title(f'Best #{i+1}: Frame {frame_num}', fontsize=12)
        ax1.axis('off')
        
        # Overlay
        ax2 = plt.subplot(5, 4, i*2+2)
        ax2.imshow(rgb)
        mask_rgb = np.zeros_like(rgb)
        mask_rgb[:,:,1] = result['pred_mask'] * 255  # Green channel
        ax2.imshow(mask_rgb, alpha=0.5)
        ax2.set_title(f'DSC: {result["dsc"]:.4f}', fontsize=12)
        ax2.axis('off')
    
    # Plot worst results
    for i, frame_num in enumerate(worst_frames):
        result = results[frame_num]
        rgb = cv2.imread(result['rgb_path'])
        rgb = cv2.cvtColor(rgb, cv2.COLOR_BGR2RGB)
        
        # Original image
        ax1 = plt.subplot(5, 4, (i+5)*2+1)
        ax1.imshow(rgb)
        ax1.set_title(f'Worst #{i+1}: Frame {frame_num}', fontsize=12)
        ax1.axis('off')
        
        # Overlay
        ax2 = plt.subplot(5, 4, (i+5)*2+2)
        ax2.imshow(rgb)
        mask_rgb = np.zeros_like(rgb)
        mask_rgb[:,:,1] = result['pred_mask'] * 255  # Green channel
        ax2.imshow(mask_rgb, alpha=0.5)
        ax2.set_title(f'DSC: {result["dsc"]:.4f}', fontsize=12)
        ax2.axis('off')
    
    plt.tight_layout(rect=[0, 0, 1, 0.97])
    plt.savefig(os.path.join(output_dir, 'best_worst_results.png'), dpi=300)
    plt.close()
    
    print(f"Visualizations saved to {output_dir}")
