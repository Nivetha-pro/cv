import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.mixture import GaussianMixture
from scipy.linalg import pinv

# === Define Paths ===
data_folder = "datasets"  # Set this to the folder where the .csv files are
files = ["CShape.csv", "Line.csv", "WShape.csv", "Sshape.csv"]
dt = 0.01

# === DMP Class ===
class DMP:
    def __init__(self, n_basis=30, alpha=48.0, beta=None):
        self.n_basis = n_basis
        self.alpha = alpha
        self.beta = beta if beta is not None else alpha / 4.0

    def generate_basis_functions(self, time, duration):
        self.centers = np.exp(-self.alpha * np.linspace(0, 1, self.n_basis))
        self.widths = np.ones(self.n_basis) * self.n_basis ** 1.5 / self.centers / duration

    def imitate(self, y_demo, duration=1.0, dt=0.01):
        self.timesteps = int(duration / dt)
        self.time = np.linspace(0, duration, self.timesteps)
        self.y0 = y_demo[0]
        self.goal = y_demo[-1]

        x = np.exp(-self.alpha * self.time / duration)
        y_demo = np.array(y_demo)
        dy = np.gradient(y_demo, axis=0) / dt
        ddy = np.gradient(dy, axis=0) / dt

        self.generate_basis_functions(self.time, duration)
        psi = np.exp(-self.widths[:, None] * (x - self.centers[:, None]) ** 2)
        f_target = (ddy - self.alpha * (self.beta * (self.goal - y_demo) - dy)) * duration**2

        denom = np.sum(psi, axis=0) + 1e-10
        psi_normalized = psi / denom
        self.weights = np.dot(psi_normalized, f_target)

    def rollout(self, duration=1.0, dt=0.01):
        y = np.zeros((self.timesteps, 2))
        dy = np.zeros((self.timesteps, 2))
        ddy = np.zeros((self.timesteps, 2))
        y[0] = self.y0
        dy[0] = 0

        x = 1.0
        for t in range(1, self.timesteps):
            psi = np.exp(-self.widths * (x - self.centers) ** 2)
            f = (psi @ self.weights) / (np.sum(psi) + 1e-10)

            ddy[t - 1] = self.alpha * (self.beta * (self.goal - y[t - 1]) - dy[t - 1]) + f / duration**2
            dy[t] = dy[t - 1] + ddy[t - 1] * dt
            y[t] = y[t - 1] + dy[t] * dt

            x -= self.alpha * x * dt / duration

        return y

# === GMR Function ===
def gmr(gmm, x_query):
    D = x_query.shape[1]
    means = gmm.means_
    covs = gmm.covariances_
    priors = gmm.weights_
    d_out = means.shape[1] - D
    y_pred = []

    for x in x_query:
        h = np.zeros(gmm.n_components)
        y = np.zeros(d_out)
        for i in range(gmm.n_components):
            mu_x = means[i, :D]
            mu_y = means[i, D:]
            Sigma_xx = covs[i][:D, :D]
            Sigma_yx = covs[i][D:, :D]

            det = np.linalg.det(Sigma_xx + 1e-6 * np.eye(D))
            norm_const = 1.0 / (np.sqrt((2 * np.pi) ** D * det))
            exp_term = np.exp(-0.5 * (x - mu_x) @ pinv(Sigma_xx) @ (x - mu_x))
            h[i] = priors[i] * norm_const * exp_term

        h /= np.sum(h) + 1e-8

        for i in range(gmm.n_components):
            mu_x = means[i, :D]
            mu_y = means[i, D:]
            Sigma_xx = covs[i][:D, :D]
            Sigma_yx = covs[i][D:, :D]
            y += h[i] * (mu_y + Sigma_yx @ pinv(Sigma_xx) @ (x - mu_x))

        y_pred.append(y)
    return np.array(y_pred)

# === Process Each File ===
for file in files:
    print(f"\nProcessing {file}...")
    path = os.path.join(data_folder, file)
    data = pd.read_csv(path).to_numpy()

    if data.shape[0] < 3:
        print(f"Skipping {file}: Not enough points ({data.shape[0]} rows)")
        continue

    # --- DMP ---
    dmp = DMP(n_basis=30)
    dmp.imitate(data)
    dmp_traj = dmp.rollout()

    # --- SEDS via GMM+GMR ---
    vel = np.gradient(data, axis=0) / dt
    X_train = np.hstack((data, vel))
    gmm = GaussianMixture(n_components=5, covariance_type='full', random_state=0).fit(X_train)
    new_vel = gmr(gmm, data)

    seds_traj = [data[0]]
    for i in range(1, len(new_vel)):
        seds_traj.append(seds_traj[-1] + new_vel[i - 1] * dt)
    seds_traj = np.array(seds_traj)

    # --- Plot ---
    plt.figure(figsize=(6, 6))
    plt.plot(data[:, 0], data[:, 1], label='Original', linewidth=2)
    plt.plot(dmp_traj[:, 0], dmp_traj[:, 1], '--', label='DMP')
    plt.plot(seds_traj[:, 0], seds_traj[:, 1], ':', label='SEDS (GMR)')
    plt.title(f"Trajectory Learning - {file[:-4]}")
    plt.xlabel("X")
    plt.ylabel("Y")
    plt.axis('equal')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()
