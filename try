import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
import zipfile

def unzip_ball_frames(zip_path, extract_to):
    if not os.path.exists(zip_path):
        raise FileNotFoundError(f"Error: The file '{zip_path}' was not found. Please check the path and try again.")
    
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(extract_to)

def load_images(image_folder, mask_folder):
    if not os.path.exists(image_folder) or not os.path.exists(mask_folder):
        raise FileNotFoundError("Error: Image or mask folder not found. Ensure the zip file is extracted correctly.")
    
    images = sorted([os.path.join(image_folder, f) for f in os.listdir(image_folder) if f.endswith(".png")])
    masks = sorted([os.path.join(mask_folder, f) for f in os.listdir(mask_folder) if f.endswith(".png")])
    
    if not images or not masks:
        raise ValueError("Error: No images or masks found in the specified directories.")
    
    return images, masks

def segment_ball(image_path):
    image = cv2.imread(image_path)
    if image is None:
        raise FileNotFoundError(f"Error: Unable to read image {image_path}")
    
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    kernel = np.ones((5, 5), np.uint8)
    morphed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)
    return morphed

def dice_similarity(mask1, mask2):
    intersection = np.logical_and(mask1, mask2).sum()
    return (2. * intersection) / (mask1.sum() + mask2.sum())

def evaluate_segmentation(image_folder, mask_folder):
    images, masks = load_images(image_folder, mask_folder)
    dsc_scores = []
    results = []
    
    for img_path, mask_path in zip(images, masks):
        segmented = segment_ball(img_path)
        ground_truth = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
        if ground_truth is None:
            raise FileNotFoundError(f"Error: Unable to read mask {mask_path}")
        
        ground_truth = (ground_truth > 127).astype(np.uint8)
        segmented = (segmented > 127).astype(np.uint8)
        dsc = dice_similarity(segmented, ground_truth)
        dsc_scores.append(dsc)
        results.append((dsc, img_path, segmented, ground_truth))
    
    return dsc_scores, results

def plot_results(dsc_scores):
    plt.figure(figsize=(10, 5))
    plt.bar(range(len(dsc_scores)), dsc_scores)
    plt.xlabel("Image Index")
    plt.ylabel("Dice Similarity Score")
    plt.title("Segmentation Performance")
    plt.show()

def show_best_worst_results(results):
    sorted_results = sorted(results, key=lambda x: x[0])
    worst_results = sorted_results[:5]
    best_results = sorted_results[-5:]
    
    fig, axes = plt.subplots(5, 4, figsize=(12, 12))
    
    for i, (dsc, img_path, segmented, ground_truth) in enumerate(worst_results + best_results):
        image = cv2.imread(img_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        axes[i, 0].imshow(image)
        axes[i, 0].set_title(f"Original Image {i+1}")
        axes[i, 1].imshow(ground_truth, cmap='gray')
        axes[i, 1].set_title(f"Ground Truth {i+1}")
        axes[i, 2].imshow(segmented, cmap='gray')
        axes[i, 2].set_title(f"Segmented {i+1}")
        axes[i, 3].text(0.5, 0.5, f"DSC: {dsc:.4f}", ha='center', va='center', fontsize=12)
        axes[i, 3].axis('off')
    
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    zip_path = "ball_frames.zip"  # Ensure this file exists in the current directory
    extract_to = "ball_frames"  # Directory to extract files
    
    try:
        unzip_ball_frames(zip_path, extract_to)
        
        image_folder = os.path.join(extract_to, "RGB")  # Adjust based on extracted folder structure
        mask_folder = os.path.join(extract_to, "Masks")
        
        dsc_scores, results = evaluate_segmentation(image_folder, mask_folder)
        print(f"Mean DSC: {np.mean(dsc_scores):.4f}, Std DSC: {np.std(dsc_scores):.4f}")
        plot_results(dsc_scores)
        show_best_worst_results(results)
    except (FileNotFoundError, ValueError) as e:
        print(e)

